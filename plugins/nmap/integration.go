package nmap

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"net"
	"sync"
	"text/template"
	"time"

	"github.com/go-pg/pg"
	"github.com/gpaulo00/gh0st/models"
)

const nmapIssue = `
# Nmap Issue
Issue generated by nmap module.

## Runnig Services
{{- if .Ports }}
| Port | State | Service |
| ---- | ----- | ------- |
{{- range $port := .Ports }}
| {{ $port.Protocol }}/{{ $port.PortID }} | {{ $port.State.State }} | {{ $port.Service }} |
{{- end }}
{{- else }}
Nmap could not find any open port in this host.
{{- end}}
`

const nmapNote = `
# Nmap Note
Note generated by nmap module.

## Operating System (OS)
{{- if .Os.OsMatches }}
| Name  | Accuracy |
| ----- | -------- |
{{- range $match := .Os.OsMatches }}
| {{ $match.Name }} | {{ $match.Accuracy }} |
{{- end }}
{{- else }}
Nmap could not guess the OS of this host.
{{- end }}

## Trace
| Address | Hostname | TTL | RTT |
| ------- | -------- | --- | --- |
{{- range $hop := .Trace.Hops }}
{{- $host := or $hop.Host "unknown" }}
| {{ $hop.IPAddr }} | {{ $host }} | {{ $hop.TTL }} | {{ $hop.RTT }}
{{- end }}

{{- if .Comment }}
## Comment
{{ .Comment }}
{{- end }}

{{- if ne .Uptime.Seconds 0 }}
## Uptime
{{ .Uptime.Lastboot }} ({{ .Uptime.Seconds }} sec.)
{{- end }}
`

var noteTemplate, issueTemplate *template.Template

func init() {
	var err error
	noteTemplate, err = template.New("nmap_note").Parse(nmapNote)
	if err != nil {
		panic(err)
	}

	issueTemplate, err = template.New("name_issue").Parse(nmapIssue)
	if err != nil {
		panic(err)
	}
}

// Import inserts all the Nmap data into database
func (r *Root) Import(db *pg.DB, ws uint64) error {
	at := time.Time(r.Start)
	var (
		hosts    []interface{} // *models.Host
		services []interface{} // *models.Service
		notes    []interface{} // *models.Note
		issues   []interface{} // *models.Issue
	)

	err := db.RunInTransaction(func(tx *pg.Tx) error {
		// generate source entry
		source := models.Source{
			WorkspaceID: ws,
			Generator:   fmt.Sprintf("%s %s", r.Scanner, r.Version),
			GeneratedAt: &at,
			SourceInfo: &models.JSON{
				"arguments": r.Args,
				"type":      r.ScanInfo.Type,
				"verbose":   r.Verbose.Level,
				"debug":     r.Debugging.Level,
			},
		}
		if err := tx.Insert(&source); err != nil {
			return err
		}

		// import hosts
		for _, host := range r.Hosts {
			if len(host.Addresses) < 1 {
				continue
			}

			// parse address
			ip := net.ParseIP(host.Addresses[0].Addr)
			if ip == nil {
				continue
			}
			hosts = append(hosts, &models.Host{
				SourceID: source.ID,
				Address:  ip,
				State:    host.Status.State,
			})
		}
		if _, err := tx.Model(hosts...).Insert(); err != nil {
			return err
		}

		// parse services, notes & issues
		for i := range r.Hosts {
			host := hosts[i].(*models.Host)
			var wg sync.WaitGroup
			wg.Add(3)

			// services
			go func() {
				defer wg.Done()
				for _, port := range r.Hosts[i].Ports {
					service := port.Service.String()
					services = append(services, &models.Service{
						HostID:   host.ID,
						Protocol: port.Protocol,
						Port:     port.PortID,
						State:    port.State.State,
						Service:  &service,
					})
				}
			}()

			// generate note of the host
			go func(host Host, mhost *models.Host) {
				defer wg.Done()
				buf := new(bytes.Buffer)
				if err := noteTemplate.Execute(buf, host); err != nil {
					panic(err)
				}
				notes = append(notes, &models.Note{
					HostID:  mhost.ID,
					Title:   fmt.Sprintf("Nmap scan of %s", mhost.Address),
					Content: buf.String(),
				})
			}(r.Hosts[i], host)

			// generate issue of the host
			go func(host Host, mhost *models.Host) {
				defer wg.Done()
				if len(host.Ports) > 0 {
					buf := new(bytes.Buffer)
					if err := issueTemplate.Execute(buf, host); err != nil {
						panic(err)
					}
					issues = append(issues, &models.Issue{
						HostID:  mhost.ID,
						Title:   fmt.Sprintf("Nmap scan of %s", mhost.Address),
						Level:   models.InfoIssue,
						Content: buf.String(),
					})
				}
			}(r.Hosts[i], host)
			wg.Wait()
		}

		// insert all
		if err := tx.Insert(services...); err != nil {
			return err
		}
		if err := tx.Insert(notes...); err != nil {
			return err
		}
		return tx.Insert(issues...)
	})

	return err
}

// Integration defines how to import a Nmap scan into gh0st
type Integration struct {
	db *pg.DB
	ws uint64
}

// Parse makes a *Root element from an io.Reader
func (n *Integration) Parse(r io.Reader) error {
	res := new(Root)
	if err := xml.NewDecoder(r).Decode(res); err != nil {
		return err
	}

	return res.Import(n.db, n.ws)
}

// New returns the Nmap plugin.
func New(db *pg.DB, ws uint64) *Integration {
	return &Integration{db, ws}
}
